= Remote ID Receiver Frontend - Architecture Documentation
:author: System Architects
:revnumber: 1.0
:revdate: 2024-03-14
:doctype: book
:icons: font
:source-highlighter: highlight.js
:toc: left
:toclevels: 4
:sectnums:
:plantuml-format: svg
:plantuml-processor: plantuml

== Introduction

This document describes the architecture of the Remote ID Receiver Frontend system using the C4 model. The C4 model is a hierarchical set of diagrams that describe the static structure of a software system.

== Level 1: System Context Diagram

The System Context diagram shows the system as a whole and its relationships with users and other systems. This diagram illustrates how the Remote ID System intercepts broadcasted information from drones, processes this data, and presents it to drone operators through an external map service. It provides a high-level view of the system's purpose and its external dependencies, showing that drone operators use the system to monitor drone activities, while the system passively receives broadcasted identification and location data from drones.

[plantuml,context-diagram,svg]
----
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Context.puml
left to right direction
LAYOUT_WITH_LEGEND()

title System Context diagram for Remote ID Receiver

Person(droneOperator, "Drone Operator", "A person responsible for monitoring and tracking drone activities")

System(remoteIdSystem, "Remote ID System", "System for monitoring and tracking drones in real-time")
System_Ext(drone, "Drone", "Unmanned aerial vehicle broadcasting identification and location data")
System_Ext(mapService, "Map Service", "Service providing geographical map data and visualization")

Rel(droneOperator, remoteIdSystem, "Monitors drone activities")
Rel(remoteIdSystem, drone, "Intercepts broadcasted identification and location data")
Rel(remoteIdSystem, mapService, "Displays drone locations")
----

== Level 2: Container Diagram

The Container diagram shows the high-level shape of the software architecture and how responsibilities are distributed across it. This diagram breaks down the Remote ID System into its major containers: a Vue.js frontend for user interaction, a Python backend for data processing, and a SQLite database for data storage. It also shows how these containers communicate with each other and with external systems, using technologies like HTTPS/REST for API communication and SQL for database operations. The diagram helps understand the system's deployment structure and technology choices.

[plantuml,container-diagram,svg]
----
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml
left to right direction
LAYOUT_WITH_LEGEND()

title Container diagram for Remote ID System

Person(droneOperator, "Drone Operator", "A person responsible for monitoring and tracking drone activities")

System_Boundary(remoteIdSystem, "Remote ID System") {
    Container(spa, "Remote ID Frontend", "Vue.js", "Single-page application for displaying drone locations and information")
    Container(backend, "Remote ID Backend", "Python", "REST API for processing and storing drone data")
    ContainerDb(database, "Drone Database", "SQLite", "Stores drone identification, location history, and system settings")
}

System_Ext(mapService, "Map Service", "Service providing geographical map data and visualization")
System_Ext(drone, "Drone", "Unmanned aerial vehicle broadcasting identification and location data")

Rel(droneOperator, spa, "Uses", "HTTPS")
Rel(spa, backend, "Fetches drone data", "HTTPS/REST")
Rel(backend, database, "Reads and writes data", "SQL")
Rel(backend, drone, "Intercepts broadcasted identification and location data", "LTE/WiFi 2.4GHz, 5GHz")
Rel(spa, mapService, "Displays drone locations", "HTTPS")
----

== Level 3: Component Diagram

The Component diagram shows how a container is made up of a number of components, what each of those components are, their responsibilities and the technology/implementation details. This diagram focuses on the Remote ID Frontend container, breaking it down into its major components: the Vue.js web application, MapLibre GL JS for map visualization, Pinia for state management, and the API client for backend communication. It shows how these components work together to provide the frontend functionality, with the web application orchestrating the other components to deliver a cohesive user experience.

[plantuml,component-diagram,svg]
----
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml
left to right direction
LAYOUT_WITH_LEGEND()

title Component diagram for Remote ID Receiver Frontend

Person(user, "User", "A user monitoring drone activities")

Container_Boundary(remoteIdFrontend, "Remote ID Receiver Frontend") {
    Container(webApp, "Web Application", "Vue.js", "Single Page Application handling UI and business logic")
    Container(apiJs, "Api.js", "JavaScript", "Unified API client handling REST and WebSocket communication")
    Container(piniaStore, "Pinia Store", "JavaScript", "State management for application data")
    Container(mapLibre, "MapLibre GL JS", "JavaScript", "Map visualization engine")
}

System(droneApi, "Remote ID Backend", "Backend API providing drone telemetry and identification data")
System_Ext(webMapService, "External Web Map Service", "External mapping service for visualization")

Rel(user, webApp, "Uses", "")
Rel(webApp, mapLibre, "Uses")
Rel(webApp, piniaStore, "Uses")
Rel(webApp, apiJs, "Uses")
Rel(apiJs, droneApi, "Fetches data from", "HTTPS/REST")
Rel(apiJs, droneApi, "Receives real-time updates from", "WebSocket")
Rel(mapLibre, webMapService, "Uses for base maps and geocoding", "HTTPS")
----

== Level 4: Code Diagram

The Code diagram shows how the components are implemented in code, including classes, interfaces, and their relationships. This diagram provides a detailed view of the MapView component's internal structure, showing how it's composed of various panels (settings, drone lists, info display), state management stores, and visualization components. It illustrates the relationships between these elements, such as how the MapView component contains and uses various panels, and how it interacts with stores and visualization strategies to manage drone data and display.

[plantuml,code-diagram,svg]
----
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml

LAYOUT_WITH_LEGEND()

title Component diagram for MapView

Container_Boundary(webApp, "Web Application") {
    Component(mapView, "MapView", "Vue Component", "Main map visualization component")

    Boundary(panels, "Map Panels") {
        Component(settingsPanel, "SettingsPanel", "Vue", "Map configuration panel")
        Component(activeDronePanel, "ActiveDronePanel", "Vue", "Currently active drones")
        Component(allDronePanel, "AllDronePanel", "Vue", "Complete drone list")
        Component(droneInfoPanel, "DroneInfoPanel", "Vue", "Selected drone details")
        Component(replayControls, "ReplayControls", "Vue", "Historical data playback")
    }

    Boundary(stores, "Stores") {
        Component(mapStore, "MapStore", "Pinia", "Drone visualization state and replay functionality")
        Component(settingsStore, "SettingsStore", "Pinia", "Application settings")
    }

    Boundary(visualization, "Visualization") {
        Component(drone, "Drone", "Class", "Drone entity with markers and attributes")
        Component(liveStrategy, "LiveVisualizationStrategy", "Class", "Real-time visualization")
        Component(replayStrategy, "ReplayVisualizationStrategy", "Class", "Replay mode visualization")
    }
}

Rel(mapView, settingsPanel, "Contains")
Rel(mapView, activeDronePanel, "Contains")
Rel(mapView, allDronePanel, "Contains")
Rel(mapView, droneInfoPanel, "Contains")
Rel(mapView, replayControls, "Contains")

Rel(mapView, mapStore, "Uses")
Rel(mapView, settingsStore, "Uses")

Rel(mapStore, liveStrategy, "Uses")
Rel(mapStore, replayStrategy, "Uses")
Rel(mapStore, drone, "Creates/Manages")

Rel(liveStrategy, drone, "Manages visualization of")
Rel(replayStrategy, drone, "Manages visualization of")
----

== Implementation Details

=== Render Loop

The render loop in MapView.vue handles continuous map updates. Here's its core logic:

[source,javascript]
----
const startRenderLoop = () => {
  const render = () => {
    // Center map on focused drone if any
    const focus_location = focusedDrone.value?.getDroneAttributes().position
    if (focus_location && !inAnimation.value) {
      map.value.setCenter(focus_location)
    }

    const strategy = mapStore.getVisualizationStrategy()

    map.value.getSource('path-source').setData(strategy.getPaths())
    map.value.getSource('drones-source').setData(strategy.getDroneFeatures())
    map.value.getSource('pilots-source').setData(strategy.getPilotFeatures())
    map.value.getSource('homes-source').setData(strategy.getHomeFeatures())

    requestAnimationFrame(render) 
  }

  render()
}
----

The loop runs every 10ms and:

* Centers the map on a focused drone (if any)
* Updates all GeoJSON sources through the current visualization strategy:
  * Drone positions
  * Pilot positions
  * Home positions
  * Path visualizations
* Adds popups for the currently selected drone
* Schedules the next frame using requestAnimationFrame for smooth rendering

=== Visualization Strategies

The application uses the Strategy pattern to handle different visualization modes:

[plantuml, "visualization-strategies", "svg"]
----
@startuml
skinparam classAttributeIconSize 0
skinparam class {
    BackgroundColor white
    BorderColor black
    ArrowColor black
}

interface "VisualizationStrategy" {
    + getDroneFeatures(): GeoJSON
    + getPilotFeatures(): GeoJSON
    + getHomeFeatures(): GeoJSON
    + getDronePopups(): Popup[]
    + getPaths(): GeoJSON
}

class "LiveVisualizationStrategy" {
    - activeDrones: Ref<Drone[]>
    + getDroneFeatures(): GeoJSON
    + getPilotFeatures(): GeoJSON
    + getHomeFeatures(): GeoJSON
    + getDronePopups(): Popup[]
    + getPaths(): GeoJSON
}

class "ReplayVisualizationStrategy" {
    - replayDrone: Ref<Drone>
    - replayPath: Ref<Position[]>
    - replayTimeStep: Ref<number>
    + getDroneFeatures(): GeoJSON
    + getPilotFeatures(): GeoJSON
    + getHomeFeatures(): GeoJSON
    + getDronePopups(): Popup[]
    + getPaths(): GeoJSON
}

LiveVisualizationStrategy ..|> VisualizationStrategy
ReplayVisualizationStrategy ..|> VisualizationStrategy

note "Both strategies return GeoJSON\nFeatureCollections for map rendering" as N1
@enduml
----

The strategy pattern is implemented through two concrete classes:

* *LiveVisualizationStrategy*: 
  * Manages visualization of multiple active drones in real-time
  * Returns GeoJSON features for all active drones based on their visibility settings
  * Filters features based on show_path, show_pilot, and show_home flags

* *ReplayVisualizationStrategy*: 
  * Handles replay visualization of a single drone's historical path
  * Updates drone position based on the current replay time step
  * Returns GeoJSON features for the single replayed drone
  * Always shows pilot and home positions during replay

Both strategies implement the same interface but handle different visualization scenarios:
* Live mode shows multiple drones with configurable visibility
* Replay mode focuses on a single drone's historical flight path

The visualization strategy is selected in the MapStore based on whether replay mode is active:

[source,javascript]
----
function getVisualizationStrategy() {
  return replayModeIsActive.value ? replayStrategy : liveStrategy
}
----

=== Drone Class Architecture

The Drone class implements a performance-optimized design that carefully manages Vue's reactivity system. The class properties are intentionally split between reactive and non-reactive storage to optimize real-time updates.

[plantuml, "drone-class", "svg"]
----
@startuml
skinparam classAttributeIconSize 0
skinparam class {
    BackgroundColor white
    BorderColor black
    ArrowColor black
}

class "Drone" {
    .. Public Properties ..
    + serial_number: string
    + show_path: Ref<boolean>
    + show_pilot: Ref<boolean>
    + show_home: Ref<boolean>
    + flights: Ref<Flight[]>
    .. Public Methods ..
    + constructor(drone_dto: DroneDTO)
    + updateLocation(position: Position)
    + getDroneAttributes(): DroneAttributes
    + remove()
    .. Private Methods ..
    - getDroneElement(): HTMLElement
    - geoJsonLineString(lng: number, lat: number): GeoJSON
}

class "DroneAttributes" << (S,#FF7700) Static Map >> {
    .. Properties ..
    + x_speed: number
    + y_speed: number
    + z_speed: number
    + rotation: number
    + altitude: number
    + height: number
    + spoofed: boolean
    + position: [number, number]
    + pilot_position: [number, number]
    + home_position: [number, number]
    + marker_home: Marker
    + marker_pilot: Marker
    + marker_drone: Marker
    + popup: Popup
    + path: GeoJSON
}

note right of DroneAttributes
  Stored in a static Map to avoid
  Vue reactivity overhead for
  frequently updating properties
end note

note left of Drone
  Properties using Vue refs
  trigger UI updates when changed
end note

Drone --> "1" DroneAttributes : uses >
@enduml
----

==== Performance Considerations

The split architecture provides several key benefits:

[plantuml, "drone-updates", "svg"]
----
@startuml
skinparam sequenceMessageAlign center
skinparam sequence {
    ArrowColor black
    LifeLineBackgroundColor white
    ParticipantBackgroundColor white
}

participant "WebSocket\nClient" as WS
participant "Drone" as D
participant "DroneAttributes\nMap" as DA
participant "Vue\nReactivity" as V
participant "DOM" as DOM

WS -> D: position update
activate D
D -> DA: update position
activate DA
DA --> D: success
deactivate DA
D --> WS: processed
deactivate D

note right
  Fast updates bypass
  Vue reactivity
end note

WS -> D: flight data update
activate D
D -> V: update flights ref
activate V
V -> DOM: trigger re-render
activate DOM
DOM --> V: rendered
deactivate DOM
V --> D: updated
deactivate V
D --> WS: processed
deactivate D

note right
  UI-related updates
  use Vue reactivity
end note
@enduml
----

1. **High-Frequency Updates**
   * Position, speed, and other rapidly changing values bypass Vue's reactivity system
   * Updates can occur every frame without performance overhead
   * No proxy objects or watchers are created for these properties

2. **UI State Management**
   * Visibility toggles and other UI state use Vue's `ref`
   * Changes trigger appropriate component re-renders
   * Reactive properties are only used where UI updates are needed

3. **Memory Efficiency**
   * The `droneAttributes` Map stores raw values without reactivity overhead
   * MapLibre GL markers and popups are managed outside Vue's reactivity system
   * Each drone instance maintains minimal reactive state

This architecture is particularly important for real-time drone tracking, where position and telemetry updates occur frequently, but UI state changes (like toggling path visibility) are relatively rare.
